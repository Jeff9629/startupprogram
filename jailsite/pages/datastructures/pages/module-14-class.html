<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CMPS 260: Module 14 Class</title>
<style>* { font-family: monospace; }</style>
<script>
//--------------------------------//
// Review Dictionaries and Hashes //
//--------------------------------//
console.log("Review Dictionaries and Hashes");

// 1. Create a hash table that uses the following function as hash function:

function HashTable() {
  // store all elements in the table array
  var table = [];

  // define hash function
  function loseloseHashCode(key) {

    var hash = 5381;
    for (var i = 0; i < key.length; i++) {
      hash = hash * 33 + key.charCodeAt(i);
    }
    return hash;
  }
  function hashCode(str) {
    var hash = 0;
    if (str.length == 0) return hash;
    for (var i = 0; i < str.length; i++) {
      var char = str.charCodeAt(i);
      hash = ((hash<<5)-hash)+char;
      hash = hash & hash;
    }
    return hash % 1013;
  }
  this.put = function(key, value) {
    // add or update a new item
    // NOTE: the method in the book has a problem
    var position = loseloseHashCode(key);
    if (table[position] === undefined) {
      table[position] = new LinkedList();
    }
    table[position].append(new ValuePair(key, value));
  };

  this.remove = function(key) {
    // remove an item
    var position = loseloseHashCode(key);
    if (table[position] !== undefined) {
      var current = table[position].getHead();
      while (current.next) {
        if (current.element.key === key) {
          table[position].remove(current.element);
          if (table[position].isEmpty()) {
            table[position] = undefined;
          }
          return true;
        }
        current = current.next;
      }
      if (current.element.key === key) {
        table[position].remove(current.element);
        if (table[position].isEmpty()) {
          table[position] = undefined;
        }
        return true;
      }
    }
    return false;
  };

  this.get = function(key) {
    // return the value that matches key
    var position = loseloseHashCode(key);
    if (table[position] !== undefined) {
      var current = table[position].getHead();
      while (current.next) {
        if (current.element.key === key) {
          return current.element.value;
        }
        current = current.next;
      }
      if (current.element.key === key) {
        return current.element.value;
      }
    }
    return undefined;
  };

  this.print = function() {
    // print the content of the hash table
    for (var i = 0; i < table.length; i++) {
      if (table[i] !== undefined) {
        console.log(i + ": " + table[i]);
      }
    }
  };
}
function ValuePair(key, value) {
  this.key = key;
  this.value = value;
  this.toString = function() {
    return "[" + this.key + " - " + this.value + "]";
  };
};

function Node(element) {
  this.element = element;
  this.next = null;
}

function LinkedList() {
  this.length = 0;
  this.head = null;
}

LinkedList.prototype.append = function(element) {
  var node = new Node(element);
  if (this.head === null) {
    this.head = node;
  }
  else {
    var tmp = this.head;
    while (tmp.next !== null) {
      tmp = tmp.next;
    }
    tmp.next = node;
  }
  this.length++;
};

LinkedList.prototype.insert = function(position, element) {
  var node = new Node(element);
  if (position === 0) {
    var oldHead = this.head;
    this.head = node;
    this.head.next = oldHead;
  }
  else {
    var tmp = this.head;
    for (var i = 0; i < position-1; i++) {
      tmp = tmp.next;
    }
    node.next = tmp.next;
    tmp.next = node;
  }
  this.length++;
};

LinkedList.prototype.removeAt = function(position) {
  var element = null;
  if (position === 0) {
    element = this.head.element;
    this.head = this.head.next;
  }
  else {
    var tmp = this.head;
    for (var i = 0; i < position-1; i++) {
      tmp = tmp.next;
    }
    element = tmp.next.element;
    var prev = tmp;
    var middle = tmp.next;
    var next = middle.next;
    prev.next = next;
  }
  this.length--;
  return element;
};

LinkedList.prototype.remove = function(element) {
  var position = this.indexOf(element);
  return this.removeAt(position);
};

LinkedList.prototype.indexOf = function(element) {
  var tmp = this.head;
  for (var i = 0; i < this.length; i++) {
    if (tmp.element === element) {
      return i;
    }
    tmp = tmp.next;
  }
  return -1;
};

LinkedList.prototype.isEmpty = function() {
  return this.length === 0;
};

LinkedList.prototype.size = function() {
  var length = 0;
  var tmp = this.head;
  while (tmp !== null) {
    length++;
    tmp = tmp.next;
  }
  return length;
};

LinkedList.prototype.getHead = function() {
  return this.head;
}

LinkedList.prototype.toString = function() {
  var current = this.head;
  var string = "List: ";
  while (current) {
    string += current.element + (current.next ? " -> " : "");
    current = current.next;
  }
  return string;
};

LinkedList.prototype.print = function() {
  console.log(this.toString());
};
// 2. Use a hash table to store phone numbers that map to names like a phone
//    book. Enter at least 5 phone numbers (do not use real data).

var hash = new HashTable();
hash.put("Gandalf", "4124567890");
hash.put("John", "4123456789");
hash.put("Tyrion", "4122345678");
hash.put("Robert", "4122345768");
hash.put("Chase", "4122345098");
console.log(hash.get("Gandalf"));
console.log(hash.get("Chase"));
hash.remove("Gandalf");
console.log(hash.get("Gandalf"));

// 3. Create a function that takes two phone books and checks whether the
//    numbers are mapped consistently. This means that if a phone number
//    appears in both phone books, they should map to exactly the same name. It
//    should return true when this is the case, false otherwise. Test your code.
//    NOTE: An algorithm like this could be used when syncing contacts.

function phoneBooksAreConsistent(pb1, pb2) {
  // todo
}



//--------------//
// Review Trees //
//--------------//
console.log("Trees");

// 1. Find the number in a binary search tree that is closest to a given value.
//    For example, if the given value is 13 and the tree contains 3, 5, 15, 23,
//    and 37 the number that should be returned is 15.



//---------------//
// Review Graphs //
//---------------//
console.log("Graphs");

// 1. Implement an algorithm that checks whether an undirected graph contains
//    a cycle. Use the graph data structure that uses the adjacency matrix as
//    internal representation.



//-----------------------------------------//
// Review Sorting and Searching Algorithms //
//-----------------------------------------//
console.log("Sorting and Searching Algorithms");

// 1. Create two arrays with random unique elements and sort them. Create a
//    third array that contains all the elements from both arrays in order.
//    Make the algorithm as fast as possible.

// 2. Implement a linear search that return the number closest to a given
//    number (instead of returning the index of element, if found).

// 3. Implement a binary search that return the number closest to a given
//    number (instead of returning the index of element, if found).



//------------------------------//
// Review Patterns of Algorithm //
//------------------------------//
console.log("Review Patterns of Algorithm");

// 1. Write a recursive function multiply(a, b) where a and a are both positive
//    integers and you can only use the + and - operators.

// 2. Write a function that reverses a string with recursion.



//-----------------------------//
// Review Algorithm Complexity //
//-----------------------------//
console.log("Algorithm Complexity");

// 1. Assess the complexity of all previous implementations.



//---------//
// Project //
//---------//
console.log("Project");

// 1. Solve Project Euler problem 1, see https://projecteuler.net/problem=1
//    Also check out https://en.wikipedia.org/wiki/Fizz_buzz

var sum = 0;
for (var i = 0; i < 1000; i++) {
  if (i % 3 === 0 || i % 5 === 0) {
    sum += i;
  }
}
console.log(sum);

// 2. Solve Project Euler problem 2, see https://projecteuler.net/problem=2

var fib = [1, 1];
var i = 2;
while (true) {
  var val = fib[i-2] + fib[i-1];
  if (val > 4000000) {
    break;
  }
  fib.push(val);
  i++;
}
var sum = 0;
for (var i = 0; i < fib.length; i++) {
  if (fib[i] % 2 === 0 && fib[i] < 4000000) {
    sum += fib[i];
  }
}
console.log(sum);

// 3. The following data represents the value of a stock over several days:
//    100, 180, 260, 310, 40, 535, 695. Suppose you can buy and sell one share
//    once over that time period. Write a program that calculates what the best
//    time is for buying and selling.
//Best time to sell is on day 7, best time to buy is on day 5

function getMaxProfit(arr) {
	var minIdx = 0;
    var maxIdx = 1;
    var currMin = 0;
    var maxProfit = 0;

    if(arr.length < 2) {
        throw new Error("Need atleast two time periods to be profitable!");
    }
    for(var i = 1; i < arr.length; i++) {
        if(arr[i] < arr[currMin]) {
        	currMin = i;
        }
        if(arr[maxIdx] - arr[minIdx] < arr[i] - arr[currMin]) {
                maxIdx = i;
            	minIdx = currMin;
        }
    }
    maxProfit  = arr[maxIdx] - arr[minIdx];
    return maxProfit;
}

var arr1 = [100, 180, 260, 310, 535, 695, 40];
console.log(getMaxProfit(arr1));


</script>
</head>
<body>
  See console!
</body>
</html>
